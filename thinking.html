<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draggable and Resizable Box</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow: hidden; /* Prevent scrollbars when dragging/resizing off-screen */
        }

        .resizable-box {
            position: absolute; /* Allows dragging anywhere */
            width: 200px;
            height: 150px;
            background-color: #4A90E2; /* Blue color */
            border: 2px solid #357ABD;
            border-radius: 12px; /* Rounded corners */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25);
            display: flex;
            flex-direction: column; /* Arrange content vertically */
            justify-content: space-between; /* Space out content and button */
            align-items: center;
            padding: 15px; /* Add padding inside the box */
            font-size: 1.25rem;
            color: white;
            cursor: grab; /* Indicate draggable */
            user-select: none; /* Prevent text selection during drag */
            transition: background-color 0.2s ease-in-out;
            text-align: center; /* Center text content */
            word-wrap: break-word; /* Ensure text wraps */
            overflow: auto; /* Allow scrolling if content exceeds size */
        }

        .resizable-box:active {
            cursor: grabbing;
            background-color: #357ABD; /* Darker blue when active */
        }

        .box-content {
            flex-grow: 1; /* Allow content to take available space */
            display: flex;
            justify-content: center;
            align-items: center;
            padding-bottom: 10px; /* Space between content and button */
            font-size: 1rem; /* Smaller font for generated text */
        }

        .button-container {
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            gap: 8px; /* Space between buttons */
            margin-top: 10px; /* Space above the button container */
            flex-shrink: 0; /* Prevent container from shrinking */
            width: 100%; /* Make buttons take full width of box */
        }

        .generate-button, .summarize-button {
            background-color: #28a745; /* Green button */
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center; /* Center text and icon */
            gap: 5px;
            width: 100%; /* Make button take full width of its container */
        }

        .generate-button:hover, .summarize-button:hover {
            background-color: #218838;
            transform: translateY(-1px);
        }

        .generate-button:active, .summarize-button:active {
            transform: translateY(0);
        }

        .generate-button:disabled, .summarize-button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }

        .summarize-button {
            background-color: #007bff; /* Blue for summarize button */
        }

        .summarize-button:hover {
            background-color: #0056b3;
        }

        /* Resizing handles */
        .handle {
            position: absolute;
            width: 14px;
            height: 14px;
            background-color: #fff;
            border: 1px solid #357ABD;
            border-radius: 50%; /* Circular handles */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .handle.top-left { top: -7px; left: -7px; cursor: nwse-resize; }
        .handle.top-right { top: -7px; right: -7px; cursor: nesw-resize; }
        .handle.bottom-left { bottom: -7px; left: -7px; cursor: nesw-resize; }
        .handle.bottom-right { bottom: -7px; right: -7px; cursor: nwse-resize; }
        .handle.top { top: -7px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .handle.bottom { bottom: -7px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .handle.left { left: -7px; top: 50%; transform: translateY(-50%); cursor: ew-resize; }
        .handle.right { right: -7px; top: 50%; transform: translateY(-50%); cursor: ew-resize; }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .resizable-box {
                width: 150px;
                height: 100px;
                font-size: 1rem;
                padding: 10px;
            }
            .handle {
                width: 10px;
                height: 10px;
            }
            .generate-button, .summarize-button {
                padding: 6px 12px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="resizable-box" id="draggableBox">
        <div class="box-content" id="boxContent">
            Drag & Resize Me!
        </div>
        <div class="button-container">
            <button id="generateContentBtn" class="generate-button">
                ✨ Generate Idea
            </button>
            <button id="summarizeContentBtn" class="summarize-button">
                ✨ Summarize Content
            </button>
        </div>
        <!-- Resizing Handles -->
        <div class="handle top-left"></div>
        <div class="handle top-right"></div>
        <div class="handle bottom-left"></div>
        <div class="handle bottom-right"></div>
        <div class="handle top"></div>
        <div class="handle bottom"></div>
        <div class="handle left"></div>
        <div class="handle right"></div>
    </div>

    <script>
        const draggableBox = document.getElementById('draggableBox');
        const handles = document.querySelectorAll('.handle');
        const generateContentBtn = document.getElementById('generateContentBtn');
        const summarizeContentBtn = document.getElementById('summarizeContentBtn'); // New button reference
        const boxContent = document.getElementById('boxContent');

        let isDragging = false;
        let isResizing = false;
        let activeHandle = null;
        let initialX, initialY, initialWidth, initialHeight, initialLeft, initialTop;

        // --- DRAGGING LOGIC ---
        draggableBox.addEventListener('mousedown', dragStart);
        draggableBox.addEventListener('touchstart', dragStart, { passive: false }); // For touch events

        function dragStart(e) {
            // Prevent resizing or button click if a handle or button was clicked
            if (e.target.classList.contains('handle') || 
                e.target.id === 'generateContentBtn' || 
                e.target.id === 'summarizeContentBtn') { // Check for new button
                return;
            }

            isDragging = true;
            draggableBox.style.cursor = 'grabbing';

            // Get initial mouse/touch position
            initialX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
            initialY = e.clientY || (e.touches ? e.touches[0].clientY : 0);

            // Get initial box position
            const rect = draggableBox.getBoundingClientRect();
            initialLeft = rect.left;
            initialTop = rect.top;

            // Add event listeners for dragging
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', dragEnd);
        }

        function drag(e) {
            if (!isDragging) return;

            e.preventDefault(); // Prevent default touch behavior (e.g., scrolling)

            const currentX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
            const currentY = e.clientY || (e.touches ? e.touches[0].clientY : 0);

            const dx = currentX - initialX;
            const dy = currentY - initialY;

            draggableBox.style.left = (initialLeft + dx) + 'px';
            draggableBox.style.top = (initialTop + dy) + 'px';
        }

        function dragEnd() {
            isDragging = false;
            draggableBox.style.cursor = 'grab';
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', dragEnd);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('touchend', dragEnd);
        }

        // --- RESIZING LOGIC ---
        handles.forEach(handle => {
            handle.addEventListener('mousedown', resizeStart);
            handle.addEventListener('touchstart', resizeStart, { passive: false });
        });

        function resizeStart(e) {
            isResizing = true;
            activeHandle = e.target;
            e.stopPropagation(); // Prevent dragStart from firing

            // Get initial mouse/touch position
            initialX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
            initialY = e.clientY || (e.touches ? e.touches[0].clientY : 0);

            // Get initial box dimensions and position
            const rect = draggableBox.getBoundingClientRect();
            initialWidth = rect.width;
            initialHeight = rect.height;
            initialLeft = rect.left;
            initialTop = rect.top;

            // Add event listeners for resizing
            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', resizeEnd);
            document.addEventListener('touchmove', resize, { passive: false });
            document.addEventListener('touchend', resizeEnd);
        }

        function resize(e) {
            if (!isResizing) return;

            e.preventDefault(); // Prevent default touch behavior

            const currentX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
            const currentY = e.clientY || (e.touches ? e.touches[0].clientY : 0);

            const dx = currentX - initialX;
            const dy = currentY - initialY;

            let newWidth = initialWidth;
            let newHeight = initialHeight;
            let newLeft = initialLeft;
            let newTop = initialTop;

            const minWidth = 150; // Minimum width for the box (increased for content)
            const minHeight = 100; // Minimum height for the box (increased for content)

            // Adjust dimensions and position based on the active handle
            if (activeHandle.classList.contains('right')) {
                newWidth = Math.max(minWidth, initialWidth + dx);
            }
            if (activeHandle.classList.contains('left')) {
                newWidth = Math.max(minWidth, initialWidth - dx);
                newLeft = initialLeft + initialWidth - newWidth;
            }
            if (activeHandle.classList.contains('bottom')) {
                newHeight = Math.max(minHeight, initialHeight + dy);
            }
            if (activeHandle.classList.contains('top')) {
                newHeight = Math.max(minHeight, initialHeight - dy);
                newTop = initialTop + initialHeight - newHeight;
            }

            // Corner handles combine horizontal and vertical resizing
            if (activeHandle.classList.contains('top-left')) {
                newWidth = Math.max(minWidth, initialWidth - dx);
                newLeft = initialLeft + initialWidth - newWidth;
                newHeight = Math.max(minHeight, initialHeight - dy);
                newTop = initialTop + initialHeight - newHeight;
            }
            if (activeHandle.classList.contains('top-right')) {
                newWidth = Math.max(minWidth, initialWidth + dx);
                newHeight = Math.max(minHeight, initialHeight - dy);
                newTop = initialTop + initialHeight - newHeight;
            }
            if (activeHandle.classList.contains('bottom-left')) {
                newWidth = Math.max(minWidth, initialWidth - dx);
                newLeft = initialLeft + initialWidth - newWidth;
                newHeight = Math.max(minHeight, initialHeight + dy);
            }
            if (activeHandle.classList.contains('bottom-right')) {
                newWidth = Math.max(minWidth, initialWidth + dx);
                newHeight = Math.max(minHeight, initialHeight + dy);
            }

            draggableBox.style.width = newWidth + 'px';
            draggableBox.style.height = newHeight + 'px';
            draggableBox.style.left = newLeft + 'px';
            draggableBox.style.top = newTop + 'px';
        }

        function resizeEnd() {
            isResizing = false;
            activeHandle = null;
            document.removeEventListener('mousemove', resize);
            document.removeEventListener('mouseup', resizeEnd);
            document.removeEventListener('touchmove', resize);
            document.removeEventListener('touchend', resizeEnd);
        }

        // Initialize position to center the box
        window.onload = function() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const boxWidth = draggableBox.offsetWidth;
            const boxHeight = draggableBox.offsetHeight;

            draggableBox.style.left = (viewportWidth / 2 - boxWidth / 2) + 'px';
            draggableBox.style.top = (viewportHeight / 2 - boxHeight / 2) + 'px';
        };

        // Handle window resize to keep box centered if it was initially
        window.addEventListener('resize', () => {
            // Re-center if it hasn't been dragged far from center
            // This is a simple re-centering, more complex logic might be needed for persistent position
            const rect = draggableBox.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (Math.abs(rect.left - (viewportWidth / 2 - rect.width / 2)) < 50 &&
                Math.abs(rect.top - (viewportHeight / 2 - rect.height / 2)) < 50) {
                draggableBox.style.left = (viewportWidth / 2 - rect.width / 2) + 'px';
                draggableBox.style.top = (viewportHeight / 2 - rect.height / 2) + 'px';
            }
        });

        // --- GEMINI API INTEGRATION: Generate Idea ---
        generateContentBtn.addEventListener('click', async () => {
            boxContent.textContent = 'Generating...'; // Show loading indicator
            generateContentBtn.disabled = true; // Disable button during generation
            summarizeContentBtn.disabled = true; // Disable summarize button too

            try {
                let chatHistory = [];
                const prompt = "Generate a very short, whimsical, and creative idea or thought related to a magical, draggable, and resizable box. Keep it to one or two sentences.";
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    boxContent.textContent = text; // Update box content with generated text
                } else {
                    boxContent.textContent = 'Failed to generate content. Please try again.';
                    console.error('Gemini API response structure unexpected:', result);
                }
            } catch (error) {
                boxContent.textContent = 'Error generating content.';
                console.error('Error calling Gemini API:', error);
            } finally {
                generateContentBtn.disabled = false; // Re-enable button
                summarizeContentBtn.disabled = false; // Re-enable summarize button
            }
        });

        // --- GEMINI API INTEGRATION: Summarize Content ---
        summarizeContentBtn.addEventListener('click', async () => {
            const contentToSummarize = boxContent.textContent.trim();

            if (!contentToSummarize || contentToSummarize === 'Generating...' || contentToSummarize === 'Summarizing...' || contentToSummarize.includes('Error')) {
                // Do not summarize if content is empty, a loading message, or an error message
                boxContent.textContent = 'Nothing to summarize yet!';
                return;
            }

            const originalContent = boxContent.textContent; // Store original content
            boxContent.textContent = 'Summarizing...'; // Show loading indicator
            generateContentBtn.disabled = true; // Disable both buttons
            summarizeContentBtn.disabled = true;

            try {
                let chatHistory = [];
                const prompt = `Please summarize the following text concisely, in one to two sentences: "${contentToSummarize}"`;
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // Keep as empty string for Canvas to provide
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    boxContent.textContent = text; // Update box content with summarized text
                } else {
                    boxContent.textContent = originalContent; // Revert to original if summary fails
                    console.error('Gemini API response structure unexpected for summarize:', result);
                }
            } catch (error) {
                boxContent.textContent = originalContent; // Revert to original on error
                console.error('Error calling Gemini API for summarize:', error);
            } finally {
                generateContentBtn.disabled = false; // Re-enable buttons
                summarizeContentBtn.disabled = false;
            }
        });

    </script>
</body>
</html>
